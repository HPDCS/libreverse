.file "dl_selector.s"

.text
.globl	dl_selector
.type	dl_selector, @function

dl_selector:
	# Push GP registers
	push	%rax			 # Salva %rax nello stack
	push	%rcx 			 # Salva i registri nell'ordine di codice numerico usato dall'IS
	push	%rdx
	push	%rbx
	mov	%rsp, %rax 		 # Ricostruisce il valore iniziale di %rsp
	sub	$8, %rsp		 # Anzichè 4 toglie 8 a rsp (sale di una posizione nello stack)
	add	$64, %rax 		 # %rsp è salito di 4 posizioni rispetto all'inizio (5, con l'indirizzo di ritorno), in più hijacker ha inserito 24 byte prima della call
	mov	%rax, (%rsp)
	push	%rbp 			 # Salva i valori degli altri registri
	push	%rsi
	push	%rdi
	
	push %r8
	push %r9
	push %r10
	push %r11
	push %r12
	push %r13
	push %r14
	push %r15

	# Push first 4 XMM registers
	sub	$16,%rsp
	movsd	%xmm0,(%rsp)
	sub	$16,%rsp
	movsd	%xmm1,(%rsp)
	sub	$16,%rsp
	movsd	%xmm2,(%rsp)
	sub	$16,%rsp
	movsd	%xmm3,(%rsp)


	# Call the instrumenter
	movq %r11,%rdi
	call dl_instrumenter


	# Pop first 4 XMM registers
	movsd	(%rsp),%xmm3
	add	$16,%rsp
	movsd	(%rsp),%xmm2
	add	$16,%rsp
	movsd	(%rsp),%xmm1
	add	$16,%rsp
	movsd	(%rsp),%xmm0
	add	$16,%rsp

	# Pop GP registers
	pop	%r15
	pop	%r14
	pop	%r13
	pop	%r12
	pop	%r11
	pop	%r10
	pop	%r9
	pop	%r8
	
	pop	%rdi 			# Ripristina i registri
	pop	%rsi
	pop	%rbp
	add	$8, %rsp		# (4->8)
 	pop	%rbx
 	pop	%rdx
 	pop	%rcx
	pop	%rax

	# %r11 contains the absolute address of the target API
	jmp *%r11			# Jump to the API

.size	dl_selector, .-dl_selector


# Model of code snippet that performs reversible tracking
.globl	jmp_to_origial_api
.globl	dl_trampoline_size

.globl	dl_trampoline
.type	dl_trampoline, @function
dl_trampoline:
	# `dl_trampoline` cannot assumes that the stack is properly
	# prepared, since it takes the control from a simple jump;
	# therefore, we must initialize param registers manually

	# lea is 4 bytes and the SIB is at 3rd byte (offset = 2)
	# movq is 7 bytes and displacement is at 4th byte (offset = 3)

	# lea's SIB is where the instrumenter will put the actual value
lea_trampoline:
	lea 0x0(%rax,%rax,1),%rdi	# initialize %rdi with the destination address
mov_trampoline:
	movq $0x0,%rsi 				# initialize %rsi with the size of the write

	# `reverse_code_generator` wants params initialize in %rdi and %rsi:
	# %rdi := the address to which the instruction will write on
	# %rsi := the size of the write the instruction will perform
	call reverse_code_generator

	# now perform the original instruction regenerated by the
	# online instrumenter (15 bytes are available, i.e. the
	# maximum size of x86 opcodes)
	nop 0x0(%rax,%rax,1)
	nop 0x0(%rax,%rax,1)
	nop 0x0(%rax,%rax,1)

	# `dl_trampoline` must return the control to the proper
	# instruction that has call it; this value is known by the
	# online inturmenter which will put the actual value here
jmp_to_origial_api:
	jmp 0x0

	# this code should be NEVER be executed
	movq $0xdeadc0de,%rax
	jmp *%rax

dl_trampoline_size:
.long	.-dl_trampoline

.size	dl_trampoline, .-dl_trampoline
