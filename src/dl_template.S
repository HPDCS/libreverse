.file "dl_template.s"

.globl	dl_trampoline_size
.globl	trmp_lea_offset
.globl	trmp_mov_offset
.globl	trmp_ret_offset
.globl	trmp_orig_offset
.globl	dl_selector_size
.globl	address_original
.globl	address_instrumented


.text

# ======================== #
# ======= dl_switch ======= #

.globl	dl_prepare_resolver
.type	dl_prepare_resolver, @function

dl_prepare_resolver:
	# Call the instrumenter
	movq %r11,%rdi
	movq -0x8(%rsp),%rsi
	call dl_instrumenter
	jmp *%rax			# Jump to the selector

.size	dl_prepare_resolver, .-dl_prepare_resolver



# ============================= #
# ======= dl_trampoline ======= #

# Model of code snippet that performs reversible tracking
.globl	dl_trampoline
.type	dl_trampoline, @function

dl_trampoline:
	# `dl_trampoline` cannot assumes that the stack is properly
	# prepared, since it takes the control from a simple jump;
	# therefore, we must initialize param registers manually

	push %rax
	push %rcx
	push %rdx
	push %rbx
	; mov %rsp,%rax
	; add	$64, %rax
	; push %rax
	push %rbp
	push %rsi
	push %rdi
	
	push %r8
	push %r9
	push %r10
	push %r11
	push %r12
	push %r13
	push %r14
	push %r15
	
	# Push dei primi 4 registri vettoriali
	sub	$16,%rsp
	movsd	%xmm0,(%rsp)
	sub	$16,%rsp
	movsd	%xmm1,(%rsp)
	sub	$16,%rsp
	movsd	%xmm2,(%rsp)
	sub	$16,%rsp
	movsd	%xmm3,(%rsp)

	# lea is 4 bytes and the SIB is at 3rd byte (offset = 2)
	# movq is 7 bytes and displacement is at 4th byte (offset = 3)

	# lea's SIB is where the instrumenter will put the actual value
	lea_trampoline:
	lea 0xd3b0(%rax,%rax,1),%rdi	# initialize %rdi with the destination address
	
	mov_trampoline:
	movq $0x0,%rsi 				# initialize %rsi with the size of the write

	# `reverse_code_generator` wants params initialize in %rdi and %rsi:
	# %rdi := the address to which the instruction will write on
	# %rsi := the size of the write the instruction will perform
	call reverse_code_generator

	movsd (%rsp),%xmm3
	add	$16,%rsp
	movsd (%rsp),%xmm2
	add	$16,%rsp
	movsd (%rsp),%xmm1
	add	$16,%rsp
	movsd (%rsp),%xmm0
	add	$16,%rsp

	pop	%r15
	pop	%r14
	pop	%r13
	pop	%r12
	pop	%r11
	pop	%r10
	pop	%r9
	pop	%r8
	
	pop	%rdi
	pop	%rsi
	pop	%rbp
	; add	$8, %rsp
 	pop	%rbx
 	pop	%rdx
 	pop	%rcx
	pop	%rax

	# now perform the original instruction regenerated by the
	# online instrumenter (15 bytes are available, i.e. the
	# maximum size of x86 opcodes)
	# (here the instrumenter must regenerate the original MOV
	# instruction that has been instrumented)
	original_instruction:
	.fill 15,1,0x90

	# `dl_trampoline` must return the control to the proper
	# instruction that has call it; this value is known by the
	# online inturmenter which will put the actual value here
	return_control:
	jmp 0x0

.size	dl_trampoline, .-dl_trampoline


# ======================== #
# ======= fake_got ======= #

.globl	call_original
.globl	call_instrumented
.globl	dl_selector_size

.globl	dl_selector
.type	dl_selector, @function

dl_selector:
	# test mode flag (0 := original, 1 := instrumented)
	movl %fs:_dso_mode@tpoff,%eax
	test %eax,%eax
	jnz call_instrumented

	# in platform mode call original version
	# here is where the instrumenter has to put the address
	call_original:
	movabs $0x0,%rax
	jmp *%rax

	# otherwise call instrumented version
	# here is where the instrumenter has to put the address
	call_instrumented:
	movabs $0x0,%rax
	jmp *%rax

dl_selector_end:
	nop

.size	dl_selector, .-dl_selector



.data
.align 4

.type	dl_trampoline_size, @object
.size	dl_trampoline_size, 4
dl_trampoline_size:
.long	dl_selector - dl_trampoline

.type	trmp_lea_offset, @object
.size	trmp_lea_offset, 4
trmp_lea_offset:
.long	(lea_trampoline - dl_trampoline) + 2

.type	trmp_mov_offset, @object
.size	trmp_mov_offset, 4
trmp_mov_offset:
.long	(mov_trampoline - dl_trampoline) + 3

.type	trmp_ret_offset, @object
.size	trmp_ret_offset, 4
trmp_ret_offset:
.long	(return_control - dl_trampoline) + 1

.type	trmp_orig_offset, @object
.size	trmp_orig_offset, 4
trmp_orig_offset:
.long	original_instruction - dl_trampoline

.type	dl_selector_size, @object
.size	dl_selector_size, 4
dl_selector_size:
.long	dl_selector_end - dl_selector

.type	address_original, @object
.size	address_original, 4
address_original:
.long	(call_original - dl_selector) + 2

.type	address_instrumented, @object
.size	address_instrumented, 4
address_instrumented:
.long	(call_instrumented - dl_selector) + 2
